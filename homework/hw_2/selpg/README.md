请TA大大先不要检查我的作业，先去检查其他人的可以吗？
我暂时还没有修改完成~
谢谢~

要求：
输入——两种方式：
在命令行上指定文件名：
command inputFile
在这里，command应该读取inputFile文件
标准输入：
command
在这里，用户从终端键盘输入，用户输入Control-D前输入的所有内容为command的输入

使用shell操作符"<"，也可以将标准输入重定向为来自文件
command < inputFile
这里command 会读它的标准输入，不过 shell／内核已将其重定向，所以标准输入来自 input_file==>so，
Question1:这里用到的函数是标准输入的还是说在标准输入函数里面判定一下转到command inputFile函数来输入？？


使用 shell 操作符“|”（pipe）也可以使标准输入来自另一个程序的标准输出，如下所示：
$ other_command | command
这里，other_command 的标准输出（stdout）被 shell／内核透明地传递至 command 的标准输入。

输出：
输出应该被写至标准输出，缺省情况下标准输出同样也是终端（也就是用户的屏幕）：
1
$ command
在这个例子中，command 的输出出现在屏幕上。

同样，使用 shell 操作符“>”（重定向标准输出）可以将标准输出重定向至文件。
1
$ command > output_file
这里，command 仍然写至它的标准输出，不过 shell／内核将其重定向，所以输出写至 output_file。
Question2：类似与Question1，是使用command的标准输出函数输出还是利用文件输出函数输出

或者，还是使用“|”操作符，command 的输出可以成为另一个程序的标准输入，如下所示：
1
$ command | other_command
在这个例子中，shell／内核安排 command 的输出成为 other_command 的输入。

错误输出：
错误输出应该被写至标准错误（stderr），缺省情况下标准错误同样也是终端（也就是用户的屏幕）：
1
$ command
这里，运行 command 时出现的任何错误消息都将被写至屏幕。
但是使用标准错误重定向，也可以将错误重定向至文件。例如：
1
$ command 2>error_file
在这个例子中，command 的正常输出在屏幕显示，而任何错误消息都被写至 error_file。
可以将标准输出和标准错误都重定向至不同的文件，如下所示：
1
$ command >output_file 2>error_file
这里，将标准输出写至 output_file，而将所有写至标准错误的内容都写至 error_file。
如果已将标准输出重定向至某一位置，也可以将标准错误重定向至同一位置。例如：
1
$ command 2>&1
在这个例子中，符号“2>&1”表示“将标准错误发送至标准输出被重定向的任何位置”，因此错误和正常的消息都将在屏幕上显示。当然，这是多余的，因为下面简单的调用
1
$ command
将做同样的事。在标准输出已被重定向至其它源，而您希望在同一命令行上将标准错误也写至同一目的地时，该特性就非常有用。例如：
1
$ command >output_file 2>&1
在这个例子中，已首先将标准输出重定向至 output_file；因此“2>&1”将使标准错误也被重定向至 output_file。

selpg 程序逻辑
如前面所说的那样，selpg 是从文本输入选择页范围的实用程序。该输入可以来自作为最后一个命令行参数指定的文件，在没有给出文件名参数时也可以来自标准输入。
selpg 首先处理所有的命令行参数。在扫描了所有的选项参数（也就是那些以连字符为前缀的参数）后，如果 selpg 发现还有一个参数，则它会接受该参数为输入文件的名称并尝试打开它以进行读取。如果没有其它参数，则 selpg 假定输入来自标准输入。

参数处理
“-sNumber”和“-eNumber”强制选项：
selpg 要求用户用两个命令行参数“-sNumber”（例如，“-s10”表示从第 10 页开始）和“-eNumber”（例如，“-e20”表示在第 20 页结束）指定要抽取的页面范围的起始页和结束页。selpg 对所给的页号进行合理性检查；换句话说，它会检查两个数字是否为有效的正整数以及结束页是否不小于起始页。这两个选项，“-sNumber”和“-eNumber”是强制性的，而且必须是命令行上在命令名 selpg 之后的头两个参数：
1
$ selpg -s10 -e20 ...

（... 是命令的余下部分，下面对它们做了描述）。
“-lNumber”和“-f”可选选项：
selpg 可以处理两种输入文本：
类型 1：该类文本的页行数固定。这是缺省类型，因此不必给出选项进行说明。也就是说，如果既没有给出“-lNumber”也没有给出“-f”选项，则 selpg 会理解为页有固定的长度（每页 72 行）。
选择 72 作为缺省值是因为在行打印机上这是很常见的页长度。这样做的意图是将最常见的命令用法作为缺省值，这样用户就不必输入多余的选项。该缺省值可以用“-lNumber”选项覆盖，如下所示：
1
$ selpg -s10 -e20 -l66 ...
这表明页有固定长度，每页为 66 行。
类型 2：该类型文本的页由 ASCII 换页字符（十进制数值为 12，在 C 中用“\f”表示）定界。该格式与“每页行数固定”格式相比的好处在于，当每页的行数有很大不同而且文件有很多页时，该格式可以节省磁盘空间。在含有文本的行后面，类型 2 的页只需要一个字符 ― 换页 ― 就可以表示该页的结束。打印机会识别换页符并自动根据在新的页开始新行所需的行数移动打印头。
将这一点与类型 1 比较：在类型 1 中，文件必须包含 PAGELEN - CURRENTPAGELEN 个新的行以将文本移至下一页，在这里 PAGELEN 是固定的页大小而 CURRENTPAGELEN 是当前页上实际文本行的数目。在此情况下，为了使打印头移至下一页的页首，打印机实际上必须打印许多新行。这在磁盘空间利用和打印机速度方面效率都很低（尽管实际的区别可能不太大）。
类型 2 格式由“-f”选项表示，如下所示：
1
$ selpg -s10 -e20 -f ...
该命令告诉 selpg 在输入中寻找换页符，并将其作为页定界符处理。
注：“-lNumber”和“-f”选项是互斥的。
“-dDestination”可选选项：
selpg 还允许用户使用“-dDestination”选项将选定的页直接发送至打印机。这里，“Destination”应该是 lp 命令“-d”选项（请参阅“man lp”）可接受的打印目的地名称。该目的地应该存在 ― selpg 不检查这一点。在运行了带“-d”选项的 selpg 命令后，若要验证该选项是否已生效，请运行命令“lpstat -t”。该命令应该显示添加到“Destination”打印队列的一项打印作业。如果当前有打印机连接至该目的地并且是启用的，则打印机应打印该输出。这一特性是用 popen() 系统调用实现的，该系统调用允许一个进程打开到另一个进程的管道，将管道用于输出或输入。在下面的示例中，我们打开到命令
1
$ lp -dDestination
的管道以便输出，并写至该管道而不是标准输出：
1
selpg -s10 -e20 -dlp1
该命令将选定的页作为打印作业发送至 lp1 打印目的地。您应该可以看到类似“request id is lp1-6”的消息。该消息来自 lp 命令；它显示打印作业标识。如果在运行 selpg 命令之后立即运行命令 lpstat -t | grep lp1 ，您应该看见 lp1 队列中的作业。如果在运行 lpstat 命令前耽搁了一些时间，那么您可能看不到该作业，因为它一旦被打印就从队列中消失了。

输入处理
一旦处理了所有的命令行参数，就使用这些指定的选项以及输入、输出源和目标来开始输入的实际处理。
selpg 通过以下方法记住当前页号：如果输入是每页行数固定的，则 selpg 统计新行数，直到达到页长度后增加页计数器。如果输入是换页定界的，则 selpg 改为统计换页符。这两种情况下，只要页计数器的值在起始页和结束页之间这一条件保持为真，selpg 就会输出文本（逐行或逐字）。当那个条件为假（也就是说，页计数器的值小于起始页或大于结束页）时，则 selpg 不再写任何输出。瞧！您得到了想输出的那些页。
