## selpg
----
### 设计说明

selpg详细设计说明见[命令行开发selpg程序](https://www.ibm.com/developerworks/cn/linux/shell/clutil/index.html)

#### 要求
编写一个能够从文件或者命令行输入起始页码和结束页码并将输出打印到命令行或者文件中的小程序
##### 输入(两种方式)
在命令行上指定文件名：
```
command inputFile
```
在这里，command应该读取inputFile文件

标准输入：
```
command
```
在这里，用户从终端键盘输入，用户输入Control-D前输入的所有内容为command的输入
还有一些其他的方式，具体请看设计说明文档

#### 输出
输出应该被写至标准输出，缺省情况下标准输出同样也是终端（也就是用户的屏幕）：
````
command
````
在这个例子中，command 的输出出现在屏幕上。

同样，使用 shell 操作符“>”（重定向标准输出）可以将标准输出重定向至文件。
````
command > output_file
````
还有输出错误文件，以及输出作为其他文件的输入，具体请看说明文档

#### selpg 程序逻辑
如前面所说的那样，selpg 是从文本输入选择页范围的实用程序。该输入可以来自作为最后一个命令行参数指定的文件，在没有给出文件名参数时也可以来自标准输入。
selpg 首先处理所有的命令行参数。在扫描了所有的选项参数（也就是那些以连字符为前缀的参数）后，如果 selpg 发现还有一个参数，则它会接受该参数为输入文件的名称并尝试打开它以进行读取。如果没有其它参数，则 selpg 假定输入来自标准输入。

#### 参数处理
“-sNumber”和“-eNumber”强制选项：
selpg 要求用户用两个命令行参数“-sNumber”（例如，“-s10”表示从第 10 页开始）和“-eNumber”（例如，“-e20”表示在第 20 页结束）指定要抽取的页面范围的起始页和结束页。selpg 对所给的页号进行合理性检查；换句话说，它会检查两个数字是否为有效的正整数以及结束页是否不小于起始页。这两个选项，“-sNumber”和“-eNumber”是强制性的，而且必须是命令行上在命令名 selpg 之后的头两个参数：
````
selpg -s10 -e20 ...
````

（... 是命令的余下部分，下面对它们做了描述）。
“-lNumber”和“-f”可选选项：
selpg 可以处理两种输入文本：
类型 1：该类文本的页行数固定。这是缺省类型，因此不必给出选项进行说明。也就是说，如果既没有给出“-lNumber”也没有给出“-f”选项，则 selpg 会理解为页有固定的长度（每页 72 行）。
选择 72 作为缺省值是因为在行打印机上这是很常见的页长度。这样做的意图是将最常见的命令用法作为缺省值，这样用户就不必输入多余的选项。该缺省值可以用“-lNumber”选项覆盖，如下所示：
````
selpg -s10 -e20 -l66 ...
````
这表明页有固定长度，每页为 66 行。
类型 2：该类型文本的页由 ASCII 换页字符（十进制数值为 12，在 C 中用“\f”表示）定界。该格式与“每页行数固定”格式相比的好处在于，当每页的行数有很大不同而且文件有很多页时，该格式可以节省磁盘空间。在含有文本的行后面，类型 2 的页只需要一个字符 ― 换页 ― 就可以表示该页的结束。打印机会识别换页符并自动根据在新的页开始新行所需的行数移动打印头。
将这一点与类型 1 比较：在类型 1 中，文件必须包含 PAGELEN - CURRENTPAGELEN 个新的行以将文本移至下一页，在这里 PAGELEN 是固定的页大小而 CURRENTPAGELEN 是当前页上实际文本行的数目。在此情况下，为了使打印头移至下一页的页首，打印机实际上必须打印许多新行。这在磁盘空间利用和打印机速度方面效率都很低（尽管实际的区别可能不太大）。
类型 2 格式由“-f”选项表示，如下所示：
````
selpg -s10 -e20 -f ...
````
该命令告诉 selpg 在输入中寻找换页符，并将其作为页定界符处理。
注：“-lNumber”和“-f”选项是互斥的。
“-dDestination”可选选项：
selpg 还允许用户使用“-dDestination”选项将选定的页直接发送至打印机。这里，“Destination”应该是 lp 命令“-d”选项（请参阅“man lp”）可接受的打印目的地名称。该目的地应该存在 ― selpg 不检查这一点。在运行了带“-d”选项的 selpg 命令后，若要验证该选项是否已生效，请运行命令“lpstat -t”。该命令应该显示添加到“Destination”打印队列的一项打印作业。如果当前有打印机连接至该目的地并且是启用的，则打印机应打印该输出。这一特性是用 popen() 系统调用实现的，该系统调用允许一个进程打开到另一个进程的管道，将管道用于输出或输入。在下面的示例中，我们打开到命令
````
lp -dDestination
````
的管道以便输出，并写至该管道而不是标准输出：
````
selpg -s10 -e20 -dlp1
````
该命令将选定的页作为打印作业发送至 lp1 打印目的地。您应该可以看到类似“request id is lp1-6”的消息。该消息来自 lp 命令；它显示打印作业标识。如果在运行 selpg 命令之后立即运行命令 lpstat -t | grep lp1 ，您应该看见 lp1 队列中的作业。如果在运行 lpstat 命令前耽搁了一些时间，那么您可能看不到该作业，因为它一旦被打印就从队列中消失了。

### 设计思路
阅读说明文档之后，可以发现文档中的主要内容即上述的**程序逻辑/命令行样式/输入输出/其他参数**；因此得到这些信息之后，我们可以根据说明文档的内容以及给定代码，将其转换为GO语言，并且在其中注意GO语言的性质以及可能会出现C语言不会出现的bug。

### 使用及测试结果
首先我们可以随意输入一个错误的命令可以看到selpg的提示正确的输入以及正确的使用：
![usage](images/2017/10/usage.png)

当输入错误的时候提示：
![error tips](images/2017/10/error-tips.png)

#### 正确命令
除了-s-e其他的选项都不带，从命令行中输入，从命令行中输出，记住以Control-D结束文本输入或者ctrlC
![1](images/2017/10/1.png)

-f寻找换页符作为换页输入
![2](images/2017/10/2.png)

从文件中输入
![3](images/2017/10/3.png)

文件可以看到如下
![4](images/2017/10/4.png)

重定向文件输入：
![5](images/2017/10/5.png)

写到输出文件
![6](images/2017/10/6.png)

输出写到命令行，错误写到error文件，但是由于没有error因此error文件为空
![7](images/2017/10/7.png)

输出写到输出文件，错误写到error文件
![8](images/2017/10/8.png)

可以通过该文件go build生成可执行文件如我的截图一样进行测试～
